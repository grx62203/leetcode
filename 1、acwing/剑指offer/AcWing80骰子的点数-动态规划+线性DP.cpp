/*
将一个骰子投掷 n 次，获得的总点数为 s，s 的可能范围为 n∼6n。

掷出某一点数，可能有多种掷法，例如投掷 2 次，掷出 3 点，共有 [1,2],[2,1] 两种掷法。

请求出投掷 n 次，掷出 n∼6n 点分别有多少种掷法。

数据范围
1≤n≤10
样例1
输入：n=1

输出：[1, 1, 1, 1, 1, 1]

解释：投掷1次，可能出现的点数为1-6，共计6种。每种点数都只有1种掷法。所以输出[1, 1, 1, 1, 1, 1]。
样例2
输入：n=2

输出：[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]

解释：投掷2次，可能出现的点数为2-12，共计11种。每种点数可能掷法数目分别为1,2,3,4,5,6,5,4,3,2,1。

      所以输出[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]。
*/

//前i次投掷和为j的掷法数目
class Solution {
public:
    vector<int> numberOfDice(int n) {
        vector<vector<int>> f(n + 1, vector<int>(6 * n + 1, 0));
        f[0][0] = 1;
        //遍历投掷次数
        for (int i = 1; i <= n; i ++ )
        	//遍历投掷和
            for (int j = 1; j <= i * 6; j ++ )
            	//遍历当前投掷机会的每个点数
                for (int k = 1; k <= 6; k ++ )
                	//在点数不超过总和的情况累加
                	//累加前一次总和为 j-k 的 掷法数目
                    if (j >= k)  f[i][j] += f[i - 1][j - k];
        //f[n]前n个不满足每个骰子最低为1的基本条件
        return vector<int>(f[n].begin() + n, f[n].end());
    }
};

