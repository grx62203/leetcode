/*
请实现一个函数用来匹配包括'.'和'*'的正则表达式。

模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。

在本题中，匹配是指字符串的所有字符匹配整个模式。

例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配。

数据范围
输入字符串长度 [0,300]。
*/
//动态规划dp---循环或者递归，循环效率更高
    //状态表示
    	//集合           所有的 s[1~i]和p[1~i]的匹配方案  //*到底表示几个字符
    	//属性(存储的值)  bool 是否存在一个合法方案
    //状态计算
    	//p[j] ！= '*'   (s[i] == p[i] || p[j] == '.' ) && f(i-1,j-1)
    	//p[j] == '*'    需要找到*代表多少个字符,枚举
			//表示0个字符||表示1个字符                           ||表示2个字符                                                      ||等等
    		//f(i, j-2)||f(i, j-1)&&(s[i]==p[j-1]||p[j-1]=='.')||f(i-2, j-2)&&(s[i]==p[j-1]||p[j-1]=='.')&&(s[i-1]==p[j-1]||p[j-1]=='.') ||

// (a*) 是一个整体
// 需要从所有匹配方式中找到一个合法方案，dp每次可以处理一堆方案
//  f(i,j)   = f(i, j-2)   || f(i-1, j-2)&&(s[i]与p[j-1]匹配)      || f(i-2, j-2)&&(s[i]与p[j-1]匹配)&&(s[i-1]与p[j-2]匹配) | .....
//  f(i-1,j) =                f(i-1, j-2)                        || f(i-2, j-2)&&(s[i-1]与p[j-2]匹配)  || .....
    //因此发现 f(i-1,j) &&(s[i]与p[j-1]匹配)   就是f(i,j)的后半部分
// f(i,j) =  f(i,j-2) || f(i-1,j) &&(s[i]与p[j-1]匹配)

//f(1,0)一定是不匹配的，所有j从1开始循环，i也要从1开始，前面赋予空格都是防止下标越界

class Solution{
public:
    bool isMatch(string s, string p){
        int n = s.size(), m = p.size();
        s = ' ' + s, p = ' ' + p;
        vector<vector<bool>> f(n+1,vector<bool>(m+1));
        f[0][0] = true;
        for(int i = 0; i <= n; i++){
            for(int j = 1; j<= m; j++){
                if(j +1 <= m && p[j + 1] == '*') continue;
                if(i && p[j] != '*'){
                    f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');
                }
                else if(p[j] == '*'){
                    f[i][j] = f[i][j - 2] || i && f[i-1][j] && (s[i] == p[j-1] || p[j-1] == '.');
                }
            }
        }
        return f[n][m];
    }
};