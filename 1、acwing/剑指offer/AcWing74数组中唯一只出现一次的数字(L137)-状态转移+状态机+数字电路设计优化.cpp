/*
在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。

请找出那个只出现一次的数字。

你可以假设满足条件的数字一定存在。

思考题：

如果要求只使用 O(n) 的时间和额外 O(1) 的空间，该怎么做呢？
数据范围
数组长度 [1,1500]。

样例
输入：[1,1,1,2,2,2,3,4,4,4]

输出：3
*/



//优化款
//可以从状态机的角度考虑。类似于dp，ones和twos的每种组合是状态，nums中的每个数是边，每个数来了之后状态之间会发生转移。
class Solution {
public:
    int findNumberAppearingOnce(vector<int>& nums) {
        int ones = 0, twos = 0;
        for (auto x : nums)
        {
        	//存储出现次数为1、3次数的
            ones = (ones ^ x) & ~twos;
            //存储出现次数为2次的
            twos = (twos ^ x) & ~ones;
        }
        return ones;
    }
};
/*
本题与前一题思路类似，前一题中，其他数都出现了两次，因此需要的状态转移方式是，如果出现两个1就抵消为0，用一个变量和异或运算即可实现，而本题是需要1出现三次时才会抵消，因此有三种状态，即1出现的次数为3k, 3k + 1, 3k + 2次

逐个位来看，要设计一个两位的状态转移，出现三个1时，循环抵消，出现0时不变，一个变量只能记录两种状态，因此要用两个变量来记录状态，用one和two两个变量来记录1出现次数
00表示1出现3k次，01表示1出现3k + 1次，10表示1出现3k + 2次

  真值表
  two     one     x       two     one
  0       0       1       0       1   
  0       1       1       1       0
  1       0       1       0       0
  0       0       0       0       0
  0       1       0       0       1
  1       0       0       1       0
先看one的状态转移方程

 one = (~one & ~two & x) | (one & ~two & ~x)
     = ~two & ((~one & x) | (one & ~x))
     = ~two & (one ^ x)
同理，再用转移后的one来求two的状态转移方程

这里，one为当且仅当1出现次数为3k + 1, tow为当且仅当1出现次数为3k + 2
因此如果题目改为，有一个数出现了两次，则返回two即可
*/


/*
个人称之为电路设计，感觉好像离散数学里有过类似的知识
个人一孔之见：这个做法好像是在做电路设计。

需要知道什么：位运算在计算机底层非常快。

参考 y总讲解，例如，一个32位数字他的一次位运算32位都会一次算出来。（大概是这个意思）

为了方便理解，可以把每个数看成只有一位。定义有限状态机初始状态：(ones, tows) = (0, 0)。
1. 如果来了 一位 数字是 1，那么状态机会改变状态，改变状态的路径为：(0, 0) -> (1, 0) -> (0, 1) -> (0, 0)。
2. 如果来了 一位 数字是 0，那么他不会修改状态，可以自己尝试一下，哪个状态放入一个 0 ，都不会改变当前状态。

所以如果 1 出现三次的倍数他最终不会改变状态，如果出现一次（或者次数 % 3 == 1），1 就会存放在 ones 中。

因此所有数字经过这个 “电路”，每个数字的相应位出现是 3 的倍数的都会处于 0 状态， 出现次数不是3的倍数的：
1. count % 3 == 1, 会存放到 ones 中
2. count % 3 == 2，会存放到 twos 中

那么这个出现一次的数，其相应为 1 的位，就会全部存放到 ones 中的相应位置，最后 ones 就是答案。


这个电路设计是如何完成的？

step1：我们顺延上面的思路，为什么要用两个数存储状态呢，
因为一个二进制位 0 或 1 只能存储出现 0 次和 1 次两个信息，
这里我们要过滤出出现三次的数，对于一个二进制来讲不足以保存出现三次这个信息，因此用两个数。

step2：为什么说很像电路设计，在座的各位应该都能回想一下计算机组成原理或者电子电路设计中加法器的设计，
并行加法器设计中为了更快的计算出结果，有两个公式，本位计算和进位计算，大家可以去翻翻书看看，其实这里很像。
一个二进制位不够，那我们在来一个位（我们不方便直接在一个数上扩展，因此我们用了两个数，一个数记录出现次数的低位 ones，一个数记录出现次数的高位 twos），

step3：剩下的唯一需要考虑的就是，如何记录出现次数的信息。
我们的两个位看作一个状态机（状态机通俗讲就是拥有某种状态的机器，在某一个状态下根据一个输入，就会转到下一个特定的状态，当然也可能是状态不变，
当当前状态和输入确定的情况下，转到的下一个状态也总是确定且相同的）。
ones 存储出现 0 次或 1 次（0对应0次或3的倍数次，1对应1次或mod3=1次，后面方便讨论就不讲这么复杂了），
tw0s记录出现2次（对应1）或3次（对应0）。关于3次为什么不是 ones 和 twos 都为1，这里记住就行最后解释。

step4：那么很简单，ones = ((!ones) & x)

作者：这个网站哟西嘚斯
链接：https://www.acwing.com/solution/content/66295/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

*/

/*
leetcode
a新的b  某个数的某一位  新的a    
00     	0     	       0
01     	1              0
01     	0       	   0
00     	1              1
10     	0              1
10     	1              0
由上可得：
b = ~a & (b ˆ x)
a = ~b & (a ˆ x)
​先求得a1（b0已知）、再求得b1（a1已知）
*/