/*
给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。

请找出数组中任意一个重复的数，但不能修改输入的数组。

数据范围
1≤n≤1000
*/
/*
两点前置知识：
1. 如何判断链表是否存在环？
双指针，一快（每次跑两格）一慢（每次跑一格），从链表首部开始遍历，两个指针最终都会进入环内，由于快指针每次比慢指针多走一格，因此快指针一定能在环内追上慢指针。
而如果链表没环，那么快慢指针不会相遇。
2. 对于有环的链表，如何找到环的起点？
基于第一点，快慢指针相遇时，我们可以证明相遇的点与环起点的距离，一定和链表首部与环起点的距离相等。
所以，从0开始，快慢指针分别以2、1的速度向前遍历，当它们相遇时，将快指针置为0，继续分别以1、1的速度向前遍历，当它们再次相遇时，此时它们的下标就是题解。

时间复杂度：慢指针每次走一格，刚好遍历到链表尾部（即环起点）处结束，因此复杂度为O(n)O(n)
空间复杂度：O(1)
*/
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int f = 0, s = 0;
        while (f == 0 || f != s) {
            f = nums[nums[f]];//速度为2
            s = nums[s];      //速度为1
        }

        f = 0;//相遇时，快指针置为0，再次相遇时退出while
        while (f != s) {
            f = nums[f];
            s = nums[s];
        }
        return s;
    }
};