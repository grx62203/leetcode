/*
给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。

每段的绳子的长度记为 k[1]、k[2]、……、k[m]。

k[1]k[2]…k[m] 可能的最大乘积是多少？

例如当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到最大的乘积 18。
*/
/*
置一个数组dp[n+1]，dp[ i ]存储绳子长度为i 时的最大乘积。依题意，绳子至少被剪一次，所以绳子长度最小为2。
外层for循环从绳长为i=2的情况开始依次计算，直到计算到绳长为n的情况。
内层for循环：当绳长为i时，由于已知至少剪一刀，我们索性假设第一刀剪在长度为j的位置(即第一段绳子长度为j)。
	剩下的那段长度为( i - j )的绳子就变成了“可剪可不剪”。那究竟是“不剪了”得到的乘积大呢，还是“继续剪余下的这段”得到乘积更大？
	我们不知道，所以需要两种情况都计算一下进行比较。其中，“不剪了”得到的乘积是j * ( i - j )，“继续剪”得到的乘积是j * dp[ i - j ]。
	取其中的较大值，就是“第一剪在j位置”能得到的最大乘积。而第一剪的所有可能位置是1,2,…,i-1。依次计算所有可能情况，取最大值即为dp[ i ]的值。

由上述过程可知，只有先依次计算出dp[2],dp[3],....的值，才能得到dp[n]的值。此为动态规划。
*/
const int N = 70;
class Solution {
public:
	int integerBreak(int n) {
        int dp[N];
        dp[2] = 1;
        // i: 代表长度为i的一段绳子
        for(int i = 3; i <= n; i++)
            //j: 代表在i长度绳子的基础上，开始剪，所以范围是 [1, n - 1];
            //这里减去的长度从1 到 i /2 就包含了所有的情况
            for(int j = 1; j <= i/2; j++)
            	// 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j*(i−j)
                // 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j*dp[i-j]
                dp[i] = max(dp[i], max(j * (i-j), j * dp[i-j]));
        return dp[n];
    }
};


//初始化默认i-j不再拆分成多个正整数
class Solution {
public:
    int cuttingRope(int n) {
        vector<int>f(n+1);
        //初始化，m=2，最大值不可能小于这个数
        for(int i=2;i<=n;i++)f[i]=i/2*(i-i/2);
        for(int i=3;i<=n;i++){
            for(int j=1;j<=i/2;j++){
                f[i]=max(f[i],f[i-j]*j);//枚举剪下的第一段绳子的长度，从1到i/2
            }
        }
        return f[n];
    }
};