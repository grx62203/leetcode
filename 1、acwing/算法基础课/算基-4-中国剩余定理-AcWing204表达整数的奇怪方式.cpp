/*
给定 2n 个整数 a1,a2,…,an 和 m1,m2,…,mn，求一个最小的非负整数 x，满足 ∀i∈[1,n],x ≡ mi (mod ai)。
*/
/*
我们令x = x0,则x是答案，但x可能是负数，我们可以进行下面的操作，是x成为小于b的满足条件的正整数：
x = ( (x % b) + b ) % b;

1、求得第一个公式与第二个公式合并后的简约版本的k1、k2（因为d不是a2-a1）
2、有解条件： a2 - a1 是m1、m2的最大公约数d的倍数
3、回归原式子一二的求差，将等式两边同时翻若干倍，使右边的d变为 a2-a1，左边的k1也变化倍数，得到真正的k1k2
4、将k1变为最小正整数解，求出k1 % (m2/d)的非负余数。k1 % (m2/d)是通解k的最小值
5、写出新的方程==此刻两个式子的解 x ，此时k1 也就成为了新的通解k的最小值
6、更新新的a1，是k项以外的项和，化解得
6、更新新的m1为 m1与m2的最小公倍数，是k项内容
如果有解，将x变为最小正整数解输出
如果无解，输出 -1
*/

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

//拓展欧几里得算法模板
LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }

    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}


int main()
{
    int n;
    cin >> n;

    LL x = 0, m1, a1;
    //x为了标记是否有答案
    //这里a与m是与md笔记的公式是相反的
    cin >> m1 >> a1;
    for (int i = 0; i < n - 1; i ++ )
    {
        LL m2, a2;
        cin >> m2 >> a2;
        LL k1, k2;
        LL d = exgcd(m1, m2, k1, k2);//1、求得第一个公式与第二个公式合并后的简约版本的k1、k2（因为d不是a2-a1）
        if ((a2 - a1) % d)           //2、有解条件： a2 - a1 是m1、m2的最大公约数d的倍数
        {
            x = -1;
            break;
        }

        k1 *= (a2 - a1) / d;               //3、回归原式子一二的求差，将等式两边同时翻若干倍，使右边的d变为 a2-a1，左边的k1也变化倍数，得到真正的k1k2

        k1 = (k1 % (m2/d) + m2/d) % (m2/d);//4、将k1变为最小正整数解，求出k1 % (m2/d)的非负余数。k1 % (m2/d)是通解k的最小值

        x = k1 * m1 + a1;                  //5、写出新的方程==此刻两个式子的解 x ，此时k1 也就成为了新的通解k的最小值

       
        a1 = k1 * m1 + a1;                 //6、更新新的a1，是k项以外的项和，化解得
 		LL m = abs(m1 / d * m2);           
        m1 = m;                            //6、更新新的m1为 m1与m2的最小公倍数，是k项内容
    }

    if (x != -1)   x = (a1 % m1 + m1) % m1;//如果有解，将x变为最小正整数解输出

    cout << x << endl;                     //如果无解，输出 -1

    return 0;
}