/*
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤1000
0<vi,wi≤1000
*/
/*
0、DP
	状态表示 f[i][j] 
		集合   
			从前i个物品选择，背包容量为j时所有的选法
			条件 （数目限制、体积限制）
				只从前i个选
				总体积不超过j
		属性   
			最大值
			(最小值)
			(数量)
	状态计算
		本质就是集合的划分
        二维     j 正序 f[i][j] = max(f[i][j] , f[i-1][j-v[i]]+w[i]); ---------if(j-v[i]>=0)  
        一维优化 j 倒序 f[j]    = max(f[j] ,     f[j - v[i]] + w[i]);    
	优化
		方程做等价变形
    遍历i，是遍历物品；遍历j，是遍历背包的容量，遍历k，是选择物品的条件，还需要判断物品的体积与剩余容量
    二维会存在不选的情况去用上一层初始化，或者有多个当前物品会合并到k=0的情况，但一维不存在
    二维化为一维的条件，且只有完全背包是反01
        a、f[i] 仅用到了f[i-1]层
        b、j与j-v[i] 均小于j，这样子就可以看为滚动数组倒序---若用到前一层的状态时,从大到小枚举, 反之从小到大哦

1、有优化版，二维化为一维的条件
	a、f[i] 仅用到了f[i-1]层
	b、j与j-v[i] 均小于j，这样子就可以看为滚动数组倒序---若用到前一层的状态时,从大到小枚举, 反之从小到大哦
2、当计算f[j]的时候，使用到了f[j-v[i]],如果正序，那么f[j-v[i]]就被dp改变过，不能被使用。
	ps：dp转移方程里面的其他f[]状态必须是原始状态，必须是没有被dp改变过的
*/

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];//体积集合、价值集合
int f[N];      //背包容积改变时的最大价值集合

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
/*************************************************************************************/
    //二维
    for(int i = 1 ; i <= n ; i++)
        for(int j = 0 ; j <= m ; j ++)
        {
            f[i][j] = f[i-1][j];//当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j-v[i]>=0)  f[i][j] = max(f[i][j], f[i-1][j-v[i]]+w[i]);
        }
    cout << f[n][m] << endl;
/*************************************************************************************/
	//一维优化
    for (int i = 1; i <= n; i ++ )//一直更新每个状态包括或者不包括第i个物品的最优解，当所有的物品都更新过后，最大体积的最优解
        for (int j = m; j >= v[i]; j -- ) //当剩余容量装不下物品的时候，结束求取            
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;

    return 0;
}




/*************************************************************************************/
思路一：
ps1： 版本1 二维
（1）状态f[i][j]定义：前 i 个物品，背包容量 j 下的最优解（最大价值）：
	当前的状态依赖于之前的状态，可以理解为从初始状态f[0] = 0开始决策，有 N 件物品，则需要 N 次决 策，每一次对第 i 件物品的决策，状态f[i][j]不断由之前的状态更新而来。
（2）当前背包容量不够（j < v[i]），没得选，因此前 i 个物品最优解即为前 i−1个物品最优解：
	对应代码：f[i][j] = f[i - 1][j]。
（3）当前背包容量够，可以选，因此需要决策选与不选第 i 个物品：

选：  f[i][j] = f[i - 1][j - v[i]] + w[i]。
不选：f[i][j] = f[i - 1][j] 。
我们的决策是如何取到最大价值，因此以上两种情况取 max() 。
代码如下：

#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
int v[MAXN];    // 体积
int w[MAXN];    // 价值 
int f[MAXN][MAXN];  // f[i][j], j体积下前i个物品的最大价值 
int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
        cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++)
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i]) 
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }           
    cout << f[n][m] << endl;
    return 0;
}

ps2：版本2 一维
将状态f[i][j]优化到一维f[j]，实际上只需要做一个等价变形。

为什么可以这样变形呢？我们定义的状态f[i][j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n][m]，因此我们只需要一维的空间来更新状态。
（1）状态f[j]定义：N 件物品，背包容量j下的最优解。
（2）注意枚举背包容量j必须从m开始。
（3）为什么一维情况下枚举背包容量需要逆序？
在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，
则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。
（4）例如，一维状态第i轮对体积为 3 的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是f[i - 1][4]，
但从小到大枚举j这里的f[4]在第i轮计算却变成了f[i][4]。
当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是f[i - 1][4]。
（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。
状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i] 。

for(int i = 1; i <= n; i++) 
    for(int j = m; j >= 0; j--)
    {
        if(j < v[i]) 
            f[i][j] = f[i - 1][j];  // 优化前
            f[j] = f[j];            // 优化后，该行自动成立，可省略。
        else    
            f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);  // 优化前
            f[j] = max(f[j], f[j - v[i]] + w[i]);                   // 优化后
    }   
实际上，只有当枚举的背包容量 >= v[i] 时才会更新状态，因此我们可以修改循环终止条件进一步优化。
for(int i = 1; i <= n; i++)
{
    for(int j = m; j >= v[i]; j--)  
        f[j] = max(f[j], f[j - v[i]] + w[i]);
} 

ps3：关于状态f[j]的补充说明

二维下的状态定义f[i][j]是前 i 件物品，背包容量 j 下的最大价值。
一维下，少了前 i 件物品这个维度，我们的代码中决策到第 i 件物品（循环到第i轮），f[j]就是前i轮已经决策的物品且背包容量 j 下的最大价值。
因此当执行完循环结构后，由于已经决策了所有物品，f[j]就是所有物品背包容量 j 下的最大价值。即一维f[j]等价于二维f[n][j]。

ps4：版本3 优化输入

我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。
因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。

#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
int f[MAXN];  // 
int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        int v, w;
        cin >> v >> w;      // 边输入边处理
        for(int j = m; j >= v; j--)
            f[j] = max(f[j], f[j - v] + w);
    }
    cout << f[m] << endl;
    return 0;
}
/*************************************************************************************/
