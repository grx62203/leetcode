/*
在一个 3×33×3 的网格中，1∼81∼8 这 88 个数字和一个 x 恰好不重不漏地分布在这 3×33×3 的网格中。

例如：

1 2 3
x 4 6
7 5 8
在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

1 2 3
4 5 6
7 8 x
例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。

交换过程如下：

1 2 3   1 2 3   1 2 3   1 2 3
x 4 6   4 x 6   4 5 6   4 5 6
7 5 8   7 5 8   7 x 8   7 8 x
现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。

输入格式
输入占一行，将 3×33×3 的初始网格描绘出来。

例如，如果初始网格如下所示：

1 2 3 
x 4 6 
7 5 8 
则输入为：1 2 3 x 4 6 7 5 8

输出格式
输出占一行，包含一个整数，表示最少交换次数。

如果不存在解决方案，则输出 −1−1。
*/
/*
八数码问题
0.1、为什么这里要swap(t[a * 3 + b], t[k]);两次呢？
因为这个for循环是遍历t的上下左右四个点，swap一下意味着xy和ab两个点换了位置，t现在是ab。判断完ab之后还要从xy出发去遍历其他三个点，所以要还原一下。
0.2、为什么要用d.count(t)是不是0来判断这个点是否为有效点呢？
因为我们要找到最短距离，要是不为零的话意味着用之前的换法已经换到这个状态过了，用现在这个状态接着换还如接着以前的状态换，以前的步数还少一些，而且这样才能把所有可能换到的状态全部枚举一遍。

1、将每次的转换结果看成一种到 初始状态有一定 distance的状态
	然后每一次上下左右遍历变换都是确认当前距离的一些状态是否是结果
2、q用来存储先进先出的队列、d用来存储某种状态是否出现、距离初始状态的distance
	每一次在d没找到这个状态，就保存距离、添加队列
	出现过的状态一定有距离，而且这个距离最短，下一次出现就跳过
3、 八数码问题bfs
        初始状态入队列，标记初始距离 = 0
        定义四个方向
	    while（队不空）
            弹出队头---优先状态
            是否到达终点---返回答案
            找到当前状态的距离、坐标x，y
            for 四个方向
                找到某个方向的新坐标a，b
				    交换坐标,变换状态
				    if 如果新坐标交换后的新状态没有出现过 ---更新状态距离、入队
				    交换坐标---清理现场
*/
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

int bfs(string state)
{
    queue<string> q;             //记录状态的队列
    unordered_map<string, int> d;//记录状态距离初始状态的distance

    q.push(state);
    d[state] = 0;

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    string end = "12345678x";
    while (q.size())
    {
        auto t = q.front();//弹出优先状态
        q.pop();

        if (t == end) return d[t];//到达终点，返回答案

        int distance = d[t];//找到当前状态的距离
        int k = t.find('x');
        int x = k / 3, y = k % 3;//找到当前状态的坐标x，y
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];//找到某个方向的新坐标a，b
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(t[a * 3 + b], t[k]);//交换位置，变换状态
                if (!d.count(t))//如果新坐标交换后的新状态没有出现过 ---更新状态距离与入队
                {
                    d[t] = distance + 1;
                    q.push(t);
                }
                swap(t[a * 3 + b], t[k]);//还原，准备下一次交换
            }
        }
    }

    return -1;
}

int main()
{
    char s[2];

    string state;
    for (int i = 0; i < 9; i ++ )
    {
        cin >> s;
        state += *s;
    }

    cout << bfs(state) << endl;

    return 0;
}