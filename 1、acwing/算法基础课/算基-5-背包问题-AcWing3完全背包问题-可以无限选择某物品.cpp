/*
有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤1000
0<vi,wi≤1000
*/
/*
0、DP
	状态表示 f[i][j] 
		集合   
			从前i个物品选择，背包容量为j时所有的选法
			条件 （数目限制、体积限制）
				只从前i个选
				总体积不超过j
		属性   
			最大值
			(最小值)
			(数量)
	状态计算
		本质就是集合的划分
        二维    j 正序 f[i][j]  = max(f[i][j] , f[i-1][j - v[i] * k] + w[i] * k);--------- for(int k = 0 ; k * v[i] <= j ; k ++)
        二维优化 j 正序 f[i][j] = max(f[i][j] , f[i][j - v[i]] + w[i]);------------------- if(j - v[i] >= 0) 
        一维优化 j 正序 f[j]    = max(f[j] ,    f[j - v[i]] + w[i]);
	优化
		方程做等价变形
    遍历i，是遍历物品；遍历j，是遍历背包的容量，遍历k，是选择物品的条件，还需要判断物品的体积与剩余容量
    二维会存在不选的情况去用上一层初始化，或者有多个当前物品会合并到k=0的情况，但一维不存在
    二维化为一维的条件，且只有完全背包是反01
        a、f[i] 仅用到了f[i-1]层
        b、j与j-v[i] 均小于j，这样子就可以看为滚动数组倒序---若用到前一层的状态时,从大到小枚举, 反之从小到大哦
*/ 

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

/*************************************************************************************/
    //二维
    for(int i = 1 ; i <= n ; i ++)
        for(int j = 0 ; j<= m ; j ++)
            for(int k = 0 ; k * v[i] <= j ; k ++)
                f[i][j] = max(f[i][j], f[i-1][j - v[i] * k] + w[i] * k);
                //不选择当前物品被合并到了k = 0 的时候
                //更新若干次k的最大值
    cout << f[n][m] << endl;
/*************************************************************************************/
/*************************************************************************************/
    //二维优化
    for(int i = 1 ; i <= n ; i ++)
        for(int j = 0 ; j <= m ; j ++)
        {
           f[i][j] = f[i-1][j];
           if(j - v[i] >= 0)   f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }
    cout << f[n][m] << endl;
/*************************************************************************************/
    //一维优化（反01背包）
    for (int i = 1; i <= n; i ++ )
        for (int j = v[i]; j <= m; j ++ )
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;

    return 0;
}




/*************************************************************************************/
思路一：
ps1：版本1 二维
#include<iostream>
using namespace std;
const int N = 1010;
int f[N][N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    	for(int j = 0 ; j<=m ;j++)
    	    for(int k = 0 ; k*v[i]<=j ; k++)
    	        f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
    	        //不选择当前物品被合并到了k = 0 的时候
    	    	//更新若干次k的最大值

    cout<<f[n][m]<<endl;
}

1、我们列举一下更新次序的内部关系：
f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
f[i , j-v]= max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-3*v]+2*w , .....)
由上两式，可得出如下递推关系： 
                        f[i][j]=max(f[i,j-v]+w , f[i-1][j]) 
2、有了上面的关系，那么其实k循环可以不要了，核心代码优化成这样：
for(int i = 1 ; i <=n ;i++)
	for(int j = 0 ; j <=m ;j++)
	{
 	   f[i][j] = f[i-1][j];
 	   if(j-v[i]>=0)    f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
	}
3、这个代码和01背包的非优化写法很像啊!!!我们对比一下，下面是01背包的核心代码
for(int i = 1 ; i <= n ; i++)
	for(int j = 0 ; j <= m ; j ++)
	{
  	 	f[i][j] = f[i-1][j];
    	if(j-v[i]>=0)  f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);
	}
4、两个代码其实只有一句不同（注意下标）

f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包
f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题

5、因为和01背包代码很相像，我们很容易想到进一步优化。核心代码可以改成下面这样
for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)//注意了，这里的j是从小到大枚举，和01背包不一样
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
/*************************************************************************************/
