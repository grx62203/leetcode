/*
Ural 大学有 N 名职员，编号为 1∼N。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

输入格式
第一行一个整数 N。

接下来 N 行，第 i 行表示 i 号职员的快乐指数 Hi。

接下来 N−1 行，每行输入一对整数 L,K，表示 K 是 L 的直接上司。

输出格式
输出最大的快乐指数。

数据范围
1≤N≤6000,
−128≤Hi≤127
*/
/*
0、DP
    状态表示 f[u][2] 
        集合   
            f[u][0]所有 u 的 子树 中 选择，并且不选 u 的 方案 快乐 最大值
            f[u][1]所有 u 的 子树 中 选择，并且  选 u 的 方案 快乐 最大值
        属性   
            最大值
    状态计算
        本质就是集合的划分
        枚举 u 的每个儿子 k 的  f[k][0]、f[k][1]
            f[u][0] += max(f[k][0],f[k][1])-----没有选择u，+ max（f选择儿子，f不选择儿子）
            f[u][1] += f[k][0]------------------选择了u，  + f不选择儿子
1、上司的舞会
    1、for 枚举前N行， 输入快乐值
    2、memset 将每个职员作为上司的单链表的表头置为 -1-------数组模拟单链表必须
    3、for 枚举前N-1行， 存入 上司关系，且添加到 每个上司 的 单链表中，单链表存储的就是上司 的直接下属们
        add(b, a) 插入一条边（双向图需要插两次），将b放到a单链表的第一个位置，更新链表头的指向
    4、while 找到校长--只有校长没有上司
    5、dfs(root) 从校长开始dfs，求得每一个子节点状态
        选择u的时候，会添加u的快乐值
        for 枚举 邻接表中 u 的每一个儿子i = 遍历 u 的单链表
            找到当前i的儿子的名字-职员j，继而 dfs(k)
            f[u][1] += f[j][0];
            f[u][0] += max(f[j][0], f[j][1]);    
            ---返回了职员j的两种状态计算结果，来累加到职员上司的两种状态
    6、输出校长的两种状态的 max
*/

#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6010;

int n;
int h[N], e[N], ne[N], idx;//h[] 表示每个上司所在的单链表的头节点、e[i] 表示节点的值 、ne[i] 表示单链表中的下一点 、idx 存储当前已经用到了哪个点
//每个链表头（里面存储的是当前单链的第一个节点）、每个节点的值、每个节点的指针、idx表示用到了哪个节点
//N是节点的索引，ne也是节点的索引，e是节点的内容（名字）
int happy[N];              //快乐值------------这里i指的是职员本身i，而不是单链表的idx
int f[N][2];               //dp状态------------这里i指的是职员本身i，而不是单链表的idx
bool has_fa[N];            //是否有上司--------这里i指的是职员本身i，而不是单链表的idx


//这里a 是上司
//邻接表模板
//插入一条边（双向图需要插两次），将b放到a单链表的第一个位置，更新链表头的指向
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
    //节点idx 的值     是 b
    //节点idx 的下一个 是 上司a 的单链表的头节点
    //上司a 的单链表 的头节点 更新为 b的链表索引idx-b，且idx++
}

//从校长开始dfs，求得每一个子节点状态
void dfs(int u)
{
    //选择u的时候，会添加u的快乐值
    f[u][1] = happy[u];

    //枚举 邻接表中 u 的每一个儿子i = 遍历 u 的单链表
    for (int i = h[u]; ~i; i = ne[i])//~i 表示 i取反为不为0，表示 i = -1 的时候停止遍历
    {
        //找到当前i的儿子的名字-职员j，继而dfs
        int j = e[i];
        dfs(j);
        //返回了职员j的两种状态计算结果，来累加到职员上司的两种状态
        f[u][1] += f[j][0];
        f[u][0] += max(f[j][0], f[j][1]);
    }
}

int main()
{
    scanf("%d", &n);
    //1、枚举前N行， 输入快乐值
    for (int i = 1; i <= n; i ++ ) scanf("%d", &happy[i]);
    //2、将每个职员作为上司的单链表的表头置为 -1-------数组模拟单链表必须
    memset(h, -1, sizeof h);
    //3、枚举前N-1行， 存入 上司关系，且添加到 每个上司 的 单链表中，单链表存储的就是上司 的直接下属们
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);//这里b 是上司
        add(b, a);            //这里b 是上司
        has_fa[a] = true;     //标记是否有上司
    }

    //4、找到校长--只有校长没有上司
    int root = 1;
    while (has_fa[root]) root ++ ;

    //5、从校长开始dfs，求得每一个子节点状态
    dfs(root);

    //6、输出校长的两种状态的 max
    printf("%d\n", max(f[root][0], f[root][1]));

    return 0;
}