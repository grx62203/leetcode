/*
有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤100
0<vi,wi,si≤100
*/
/*
0、DP
	状态表示 f[i][j] 
		集合   
			从前i个物品选择，背包容量为j时所有的选法
			条件 （数目限制、体积限制）
				只从前i个选
				总体积不超过j
		属性   
			最大值
			(最小值)
			(数量)
	状态计算
		本质就是集合的划分
        二维    j 正序 f[i][j] = max(f[i][j] , f[i - 1][j - v[i] * k] + w[i] * k);--------- for(int k = 0; k <= s[i] && k * v[i] <= j ; k ++ )
        一维优化 j 倒序 f[j]   = max(f[j] ,    f[j - v[i] * k] + w[i] * k);---------------- for(int k = 1; k <= s[i] && k * v[i] <= j ; k ++ ) 
        一维优化 j 倒序 f[j]   = max(f[j] ,    f[j - v[i]] + w[i]);-------------------------将每个物品的多数量强拆成若干单独物品，然后类01
	优化
		方程做等价变形
    遍历i，是遍历物品；遍历j，是遍历背包的容量，遍历k，是选择物品的条件，还需要判断物品的体积与剩余容量
    二维会存在不选的情况去用上一层初始化，或者有多个当前物品会合并到k=0的情况，但一维不存在
    二维化为一维的条件，且只有完全背包是反01
        a、f[i] 仅用到了f[i-1]层
        b、j与j-v[i] 均小于j，这样子就可以看为滚动数组倒序---若用到前一层的状态时,从大到小枚举, 反之从小到大哦

*/


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i] >> s[i];
/*************************************************************************************/
    //二维
    for(int i = 1; i <= n ; i ++ )
        for(int j = 0; j <= m ; j ++ )
            for(int k = 0; k <= s[i] && k * v[i] <= j ; k ++ )
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
    cout << f[n][m] << endl;
/*************************************************************************************/
    //一维优化（类01背包）
    for(int i = 1; i <= n; i ++)
        for(int j = m; j >= 0; j --)   
            for(int k = 1; k <= s[i] && k * v[i] <= j ; k ++ ) 
                f[j] = max(f[j], f[j - v[i] * k] + w[i] * k);
    cout << f[n][m] << endl;
    return 0;
}




/*************************************************************************************/
思路一：
ps1：版本一(把多重背包拆成01背包)：
#include <bits/stdc++.h>
using namespace std;
int a[10005],b[10005],t=0,n,m,dp[10005]={ },v,w,s;
int main()
{
    cin>>n>>m;
    while(n--)
    {
        cin>>v>>w>>s;
        //将若干数量拆开，化为 a-b 的01背包
        while(s--)
        {
            a[++t]=v;
            b[t]=w;
        }//死拆，把多重背包拆成01背包
    }
    for(int i=1;i<=t;i++)
    	for(int j=m;j>=a[i];j--)
    		dp[j]=max(dp[j-a[i]]+b[i],dp[j]);//直接套01背包的板子
    cout<<dp[m]<<endl;
    return 0;
}
ps2：版本二优化(把多重背包拆成01背包)：
#include <bits/stdc++.h>
using namespace std;
int dp[1005],n,t,v,w,s;
main()
{
    cin>>n>>t;
    while(n--)
    {
    	cin>>w>>v>>s;
    	for(int i=1;i<=s;i++)
   			for(int j=t;j>=w;j--)
    			dp[j]=max(dp[j],dp[j-w]+v);
    }
    cout<<dp[t];
}
/*************************************************************************************/