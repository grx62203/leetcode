/*
在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？

输入格式
第一行输入一个整数 N。

第二行输入 NN 个整数 A1～AN。

输出格式
输出一个整数表示答案。

数据范围
1≤N≤105
0≤Ai<231
*/
/*
Trie求最大异或对
异或=不同为 1 相同为 0
非暴力做法
每一个元素都可以拆分字符串类似的，化为字典树
*/
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 3100010;//每个数N都有31个子元素

int n;
int a[N], son[M][2], idx;
//字典树插入过程（0与1，不同于模板的26个字母）
void insert(int x)
{
    int p = 0;
    for (int i = 30; i >= 0; i -- )
    {
        // x >> i & 1  取出第i位的值 是1 或者 0
        int &s = son[p][x >> i & 1];
        //如果1 或者 0 这个儿子不存在，那么插入
        if (!s) s = ++ idx;//从idx=1 开始插入
        //更新p为p的儿子
        p = s;
    }
    //这里缺少了一个模板的标记尾巴
}
//字典树查询过程
int search(int x)
{
    int p = 0, res = 0;
    //if和else交替也能找到一个唯一最大的贪心异或结果-字符串（31位二进制数）
    for (int i = 30; i >= 0; i -- )
    {
        // x >> i & 1  取出第i位的值 是1 或者 0
        int s = x >> i & 1;
        //如果存在 与<x 的当前i位>相反 的 枝干 ，代表当前查询 <x 的当前i位> 可以异或得1
            //虽然每次只判断 ！s，但是因为字典树的原因，可以保证从前到后异或结束，贪心得到的便是<<最佳答案对应的 异或另一半 对应字符串>>-其他某个整数
        if (son[p][!s])
        {
            res += 1 << i; //在当前查询x 的当前i位 上面 +1，对应的是最佳答案
            p = son[p][!s];//在<<最佳答案对应的 异或另一半 对应字符串>>的前半段 上面延续下一代
        }
        //如果不存在 与<x 的当前i位>相反 的 枝干，延续x
            //代表当前查询x 的当前i位 异或只能得0，
            //也就是 <<最佳答案对应的 异或另一半 对应字符串>>的前半段 的 第i位数字都是 同 <x 的当前i位> 一样
        else p = son[p][s];
    }
    //返回x的唯一最大的贪心异或结果
        //除了最后一步，其余能找到的 <<最佳答案对应的 异或另一半 对应字符串>> 不唯一，直到最后才唯一确定
    return res;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        scanf("%d", &a[i]);
        insert(a[i]);
    }

    int res = 0;
    //异或对max的要求 从高位到低位，尽量 为 1,
    //也就是从高位到低位找不同，不同的越多， res中 1就越多，
    //但是 max取决于 每次res二进制字符串 实际的大小
    for (int i = 0; i < n; i ++ ) res = max(res, search(a[i]));

    printf("%d\n", res);

    return 0;
}