/*
求把 N×M 的棋盘分割成若干个 1×2 的的长方形，有多少种方案。

例如当 N=2，M=4 时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。

如下图所示：

2411_1.jpg

输入格式
输入包含多组测试用例。

每组测试用例占一行，包含两个整数 N 和 M。

当输入用例 N=0，M=0 时，表示输入终止，且该用例无需处理。

输出格式
每个测试用例输出一个结果，每个结果占一行。

数据范围
1≤N,M≤11
*/
/*
1、核心：先放横的、再放竖的
2、总方案数 = 只放横的合法的方案数
3、如何判断合法
	剩余位置 能不能塞满 竖的
		按列来看，每一列内部所有连续空的方格数目为 偶数
4、DP
	状态表示 f[i][j] 
		集合   
			已经将 前 i - 1 列摆好，且从 i - 1 列伸出到 i 列 状态从上到下二进制表示为 j 状态 的所有方案
		属性   
			数量
	状态计算
		本质就是集合的划分
		枚举 i - 1 列的合法情况，此时 i 列状态 为 j，i - 1 列状态 为 k
			j & k = 0-----------------------------------------全1为1
				同一行 ，i-1 列有格子右的时候， i   列不能有格子右
				同一行 ，i   列有格子右的时候， i-1 列不能有格子右 
			j | k 不存在连续奇数个 0 	
				i 列 与 i - 1 列 共同连续空白格子 不能是 奇数
		f[i][j] += f[i-1][k]
5、for (int i = 0; i < 1 << n; i ++ )// 直至 1 左移 n 位。 也就是1 ~ 2^n
6、if (i >> j & 1)//i 的 从右第 j 位 = 1
7、if (cnt & 1) //如果cnt 是奇数
8、朴素写法
	当 n 或者 m 有一个不等于 0 就while
		for 预处理所有状态的合法性
			当前状态连续0 的计数清0
			假设当前状态合法，也就是偶数个 连续0
			for 遍历某个状态的所有位
				if 1、如果当前状态 从右第j位 = 1 且 上一段连续的 0 有奇数个， 则 当前状态 不合法 ，且  连续0 计数清 0 
				else 2、如果当前状态 从右第j位 = 0 不管前一段怎么样，都连续0 计数 +1
			3、如果当前状态从右 n 位遍历结束，最后一段连续0 的个数 为 奇数，则 当前状态 不合法
		memset 一定要记得初始化成0，对于每个新的输入要重新计算f[N][M]
		f[0][0] = 1 第一列，一个格子右都没有也是一种状态
		for 枚举 除了第一列的所有列
			for 枚举 i 列 的状态 j
				for 枚举 i - 1 列 的状态 k
					if 如果 （前后两列任意一行不存在全为1） 且 （前后两列的共同连续空白 为 奇数个）
                        f[i][j] += f[i - 1][k]---则累加当前i - 1 列状态的方案
		cout << f[m][0]---0~m-1列是题目中可以摆方块的范围，累加到前 m 列填充完毕后导出
9、时间复杂度
    dp的时间复杂度 =状态表示× 状态转移
    状态表示 f[i][j] 第一维i可取11，第二维j（二进制数）可取211211 ，所以状态表示 11×21111×211
    状态转移 也是211211
    所以总的时间复杂度
        11×211×211≈4×10711×211×211≈4×107 可以过
*/

        
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12, M = 1 << N;  //12、2^12

int n, m;           //行数、列数
long long f[N][M];  //状态转移方程
bool st[M];         //某个状态是否合法

int main()
{
	//当 n 或者 m 有一个不等于 0 就while
    while (cin >> n >> m, n || m)
    {
    	//预处理所有状态是不是 不存在连续奇数个 0 
    	//状态就是 000000、 000001、000010、000011、、、、111111 ，直至 1000000，就可以预处理所有 六位数 二进制的所有状态
    	//遍历所有状态，每个状态都是代表某一列 的 是否有格子右
        for (int i = 0; i < 1 << n; i ++ )// 直至 1 左移 n 位。 也就是1 ~ 2^n
        {
            int cnt = 0; //当前状态连续0 的计数清0
            st[i] = true;//假设当前状态合法，也就是偶数个 连续0
            //遍历某个状态的所有位
            for (int j = 0; j < n; j ++ )// 直至 n 位
                //1、如果当前状态 从右第j位 = 1 且 上一段连续的 0 有奇数个， 则 当前状态 不合法 ，且  连续0 计数清 0     	
                if (i >> j & 1)//i 的 从右第 j 位 = 1
                {
                    if (cnt & 1) st[i] = false;//出现了奇数个 连续0 ，不合法
                    cnt = 0;                   //连续0 计数清0
                }
                //2、如果当前状态 从右第j位 = 0 不管前一段怎么样，都 连续0 计数 +1
                else cnt ++ ;
            //3、如果当前状态从右 n 位遍历结束，最后一段连续0 的个数 为 奇数，则 当前状态 不合法
            if (cnt & 1) st[i] = false;
        }
        //一定要记得初始化成0，对于每个新的输入要重新计算f[N][M]
        memset(f, 0, sizeof f);
        f[0][0] = 1;//第一列，一个格子右都没有也是一种状态
        //枚举 除了第一列的所有列
        for (int i = 1; i <= m; i ++ )
        	//枚举 i 列 的状态 j
            for (int j = 0; j < 1 << n; j ++ )
            	//枚举 i - 1 列 的状态 k
                for (int k = 0; k < 1 << n; k ++ )
                	//如果 （前后两列任意一行不存在全1为1） 且 （前后两列的共同连续空白 为 奇数个），则累加当前i - 1 列状态的方案
                    if ((j & k) == 0 && st[j | k]) f[i][j] += f[i - 1][k];
        //0~m-1列是题目中可以摆方块的范围，累加到前 m 列填充完毕后导出
        cout << f[m][0] << endl;
    }
    return 0;
}



