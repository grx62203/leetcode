/*
输入一个包含 n 个方程 n 个未知数的异或线性方程组。

方程组中的系数和常数为 0 或 1，每个未知数的取值也为 0 或 1。

求解这个方程组。

异或线性方程组示例如下：

M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]
M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]
…
M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n]
其中 ^ 表示异或(XOR)，M[i][j] 表示第 i 个式子中 x[j] 的系数，B[i] 是第 i 个方程右端的常数，取值均为 0 或 1。

输入格式
第一行包含整数 n。

接下来 n 行，每行包含 n+1 个整数 0 或 1，表示一个方程的 n 个系数以及等号右侧的常数。

输出格式
如果给定线性方程组存在唯一解，则输出共 n 行，其中第 i 行输出第 i 个未知数的解。

如果给定线性方程组存在多组解，则输出 Multiple sets of solutions。

如果给定线性方程组无解，则输出 No solution。
*/
/*
1、异或 相同为0，不同为1
2、方程中若干x变量的参数要么是1，要么是0
3、类似于解线性方程组
4、gauss()
    for 枚举列（正对角线）
        for 枚举包括当前行下面的若干行--------------------------找到若干行最后一个 当前列参数 == 1 的行，赋值于t
            if 如果若干行中的当前列的所有参数都是0 ，就没必要去算    
        for 枚举n次-------------------------------------------将最后满足条件的的 一整行 换到最顶端
        for 枚举换行之后的新行下面的所有行
            if 这一行的第一个元素（对应当前列参）不为0
                for 枚举某一行的后段所有列参-------------------用选中行的列参 将 首列参不为0的行的所有列参 异或，将枚举行便成了变量更少的新的方程
*/

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;


int n;
int a[N][N];

//高斯消元模板
int gauss()// 高斯消元，答案存于a[i][n]中，0 <= i < n
{
    int c, r;//列、行
    //枚举列（正对角线）
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        //枚举包括当前行下面的若干行
        for (int i = r; i < n; i ++ )                            // 1、找到若干行最后一个 当前列参数 == 1 的行，赋值于t
            if (a[i][c])
                t = i;

        if (!a[t][c]) continue;                                  // 如果若干行中的当前列的所有参数都是0 ，就没必要去算了，         

        for (int i = c; i <= n; i ++ ) swap(a[r][i], a[t][i]);   // 2、将最后满足条件的的 一整行 换到最顶端
        //枚举换行之后的新行下面的所有行
        for (int i = r + 1; i < n; i ++ )
            if (a[i][c])                                         // 如果这一行的第一个元素（对应当前列参）不为0
            	//枚举某一行的后段所有列参
                for (int j = n; j >= c; j -- ) 
                    a[i][j] ^= a[r][j];                          // 3、用选中行的列参 将 首列参不为0的行的所有列参 异或，将枚举行便成了变量更少的新的方程

        r ++ ;
    }

    if (r < n)//4、方程个数小于 n ，没有唯一解
    {
    	// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0，
        for (int i = r; i < n; i ++ )
            if (a[i][n])             //如果 b_ 出现了非0，则无解 
           	// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解
                return 2;
        return 1;                    // 否则， 0 = 0，就是r ~ n-1的方程都是多余方程有无穷多组解
    }

    //5、遍历每一行求唯一解 ↓，从下往上回代，得到方程的解
    for (int i = n - 1; i >= 0; i -- )    //从下往上
        for (int j = i + 1; j < n; j ++ ) //从主对角线+1 往最后
            a[i][n] ^= a[i][j] * a[j][n];//方程的右值 异或 当前行后面 若干x*x参数。便有当前行第一个x 的结果，也就是第一个x对应的解
            //因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出

    return 0;
}


int main()
{
	//输入方程
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n + 1; j ++ )
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
    {
        for (int i = 0; i < n; i ++ ) cout << a[i][n] << endl;//依次输出从前到后每个x对应的解
    }
    else if (t == 1) puts("Multiple sets of solutions");
    else puts("No solution");

    return 0;
}