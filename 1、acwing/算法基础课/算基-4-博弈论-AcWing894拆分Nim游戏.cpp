/*
给定 n 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆规模更小的石子（新堆规模可以为 0，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 n。

第二行包含 n 个整数，其中第 i 个整数表示第 i 堆石子的数量 ai。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1≤n,ai≤100
*/
/*
0-1、sg非零状态可以说明到0，必胜
0-2、一般有很多图，玩家可以选择任何一个图进行操作，当所有的图都走不了（某刻sg=0），才必输，用异或来求所有图是否都sg为0
0-3、所有终点的sg=0，非终点的sg是通过遍历能到达状态的sg来求取的，sg 等于能到达 状态的集合对应的sg集合中的 未出现的最小非负整数

1、为什么这个地方直接是 S.insert( sg(i) ^ sg(j) )， 不需要满足 i + j == x 吗？
    这道题目拿走一堆石子之后，再重新放回的两堆石子的总数不需要和原来那堆相等，只需要新的两堆个数分别严格小于拿走那堆的个数就可以了。
2、那堆石子全部拿完吗？ 如果拿完的话，放入两个新堆，两个新堆的和不应该是大于等于原来那堆吗？
    每次必须拿完整堆石子，然后放入两堆数量更少的石子，新放入的两堆石子的数量必须严格小于拿走的那堆，但总和可以超过原来那堆，也可以小于原来那堆。
4、想问一下这一讲的最后一问，894. 拆分-Nim游戏，SG函数这个定理：SG(a, b) = SG(a) ^ SG(b) ，怎么理解（或者说怎么证明啊）？
    从一开始的 a∧1a∧2⋯∧an到集合Nim问题里用 SG(G) 代表一个图当前局面状态，
    本质上都是在用一种类似分治的方式把小局面用异或的方法合起来形成了对大局面的判断。
    SG(a,b)=SG(a)∧SG(b)也是如此，用分成两块的 a和 b 的状态异或起来表示局面 (a,b) 的状态。这是对 SG的理解。
    我有一个对之所以用异或方法的粗浅证明，就是如果异或得到 SG(G)最终为 0，那也就说明有两堆是一致的，
    无论是分块还是集合还是普通Nim都是这个思路，后手都可以模仿先手的思路，直至先手无路可走；
    反之 SG(G)≠0时，先手可以通过y总讲的方式造成可模仿局面，也就是必胜局面。
5、想问一下这一讲的最后一问，894. 拆分-Nim游戏，SG函数这个定理：SG(a, b) = SG(a) ^ SG(b) ，怎么理解（或者说怎么证明啊）？
    因为堆a可以变成两堆，所以枚举求取可以变成的任意两堆局面的异或值 ，这些异或值就是堆a可以到达的状态的sg值
*/
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

const int N = 110;


int n;
int f[N];//n堆石头的个数集合


//求有向无环图的sg值，返回初始状态的sg值
int sg(int x)
{
	//如果若干组合操作到达同一状态，省略遍历
    if (f[x] != -1) return f[x];

    //存取所有可以到达的局面
    //因为堆a可以变成两堆，所以枚举求取可以变成的任意两堆局面的异或值 ，这些异或值就是堆a可以到达的状态的sg值
    unordered_set<int> S;
    for (int i = 0; i < x; i ++ )
        for (int j = 0; j <= i; j ++ )
            S.insert(sg(i) ^ sg(j));
    //寻找最小的非负整数
    //只有x - sum == 0 的时候，sg 才等于0
    for (int i = 0;; i ++ )
        if (!S.count(i))
            return f[x] = i;
}


int main()
{
    cin >> n;

    memset(f, -1, sizeof f);

    int res = 0;
    while (n -- )
    {
        int x;
        cin >> x;
        res ^= sg(x);
    }

    if (res) puts("Yes");
    else puts("No");

    return 0;
}