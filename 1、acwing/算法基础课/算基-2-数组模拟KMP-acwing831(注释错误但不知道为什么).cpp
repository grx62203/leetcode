/*
给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模板串 P 在模式串 S 中多次作为子串出现。

求出模板串 P 在模式串 S 中所有出现的位置的起始下标。

输入格式
第一行输入整数 N，表示字符串 P 的长度。

第二行输入字符串 P。

第三行输入整数 M，表示字符串 S 的长度。

第四行输入字符串 S。

输出格式
共一行，输出所有出现位置的起始下标（下标从 00 开始计数），整数之间用空格隔开。

数据范围
1≤N≤105
1≤M≤106
*/
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
int ne[N];
char s[M], p[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;//输入字符串的时候，下标＋1+

    //模板-求next数组-针对子串
    for (int i = 2, j = 0; i <= n; i ++ )
    {
        //当j不为0 且 前面字符和后面字符不匹配的时候，规则回退从第一个不相等的地方开始
        while (j && p[i] != p[j + 1]) j = ne[j];
        //当前面字符和后面字符 一样的时候，j++
        if (p[i] == p[j + 1]) j ++ ;
        //当第一次不相等的时候，定规则说明这就是 i 对应的规则回退的位置
        ne[i] = j;
    }

    //模板-字符串匹配
    for (int i = 1, j = 0; i <= m; i ++ )
    {
        //当j不为0 且 前面字符和后面字符不匹配的时候，规则回退j，跳过字符串与 子串前缀串 相同串的匹配
        while (j && s[i] != p[j + 1]) j = ne[j];
        //当字符串字符和子串字符 一样的时候，j++
        if (s[i] == p[j + 1]) j ++ ;
        //如果匹配成功的话
        if (j == n)
        {
            printf("%d ", i - n);//输出子串匹配成功的起始位置
            j = ne[j];//规则回退j， 跳过字符串与 子串后缀串 相同串的匹配（ 从下一个i开始）
        }
    }

    return 0;
}