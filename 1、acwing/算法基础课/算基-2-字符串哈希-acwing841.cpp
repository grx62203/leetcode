/*
给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

输入格式
第一行包含整数 n 和 m，表示字符串长度和询问次数。

第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。

接下来 m 行，每行包含四个整数 l1,r1,l2,r2，表示一次询问所涉及的两个区间。

注意，字符串的位置从 1 开始编号。

输出格式
对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。

每个结果占一行。

数据范围
1≤n,m≤105
*/
/*
字符串哈希
就是用前缀哈希 做差 来求得 子串哈希的过程
1、h[r] - h[l - 1] * p[r - l + 1];    //l-r闭区间范围的子串哈希值公式
2、h[i] = h[i - 1] * P + str[i];      //前 i位 的字符串哈希值公式（前缀哈希）
3、p[i] = p[i - 1] * P;               //计算 i 个字符对应的 P进制次数
除了循环节得用kmp，其他大部分都可以代替kmp
*/
#include <iostream>
#include <algorithm>

using namespace std;

typedef unsigned long long ULL;

const int N = 100010, P = 131;//固定用131或者

int n, m;
char str[N];
ULL h[N], p[N];//前N位字符串的哈希值、N个字符的P进制次数

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];//l-r闭区间范围的子串哈希值公式： 高位 - 低位 * 相差次数(100或者1000)
    // 前l-1 的字符串哈希哈希值 放大到   前r的字符串哈希值 同级别， 被相减得到 l-r范围的子串哈希
    // 意思是将 小部分 放大到和 大部分一个 数量级，然后才可以 被大部分相减，得到 L到R之间的哈希值（闭区间的L与R）
}

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s", str + 1);//字符串从下标1 开始

    p[0] = 1;//省略了 h[0] = 0
    for (int i = 1; i <= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];//前 i位 的字符串哈希值公式（前缀哈希）
        p[i] = p[i - 1] * P;         //计算 i 个字符对应的 P进制次数
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);

        if (get(l1, r1) == get(l2, r2)) puts("Yes");//判断子串 两个区间 是否一样
        else puts("No");
    }

    return 0;
}