/*
给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。

在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

输入格式
第一行包含两个整数 R 和 C。

接下来 R 行，每行包含 C 个整数，表示完整的二维矩阵。

输出格式
输出一个整数，表示可完成的最长滑雪长度。

数据范围
1≤R,C≤300,
0≤矩阵中整数≤10000
*/
/*
0、DP
    状态表示 f[i][j] [行][列]
        集合   
            所有 从 ij 点开始滑雪的路径 最大值
        属性   
            最大值
    状态计算
        本质就是集合的划分
        枚举 四个方向 
            f[i][j] = max(f[合法向上]+1，f[合法向右]+1，f[合法向下]+1，f[合法向左]+1)
    不能有环
1、假设状态 = 1, 枚举四个方向，若合法，则求得 当前点的状态 =  max（1 ， 与各个合法方向的状态+1）
    ---因为最次滑雪距离也有 1，只有当前这个格子
*/


#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310;

int n, m;
int g[N][N];//高度
int f[N][N];//dp状态

//枚举四个方向的偏移量
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

//递归某个点的合法方向
int dp(int x, int y)
{
    //如果 当前的状态被计算，则直接返回
    int &v = f[x][y];
    if (v != -1) return v;

    //假设状态 = 1, 枚举四个方向，若合法，则求得 当前点的状态 =  max（1 ， 与各个合法方向的状态+1）
    v = 1;//因为最次滑雪距离也有 1，只有当前这个格子
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 1 && a <= n && b >= 1 && b <= m && g[x][y] > g[a][b])
            v = max(v, dp(a, b) + 1);
    }

    return v;
}

int main()
{
    //读入高度
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &g[i][j]);
    //重置状态 = -1
    memset(f, -1, sizeof f);

    //枚举 每个点出发的情况，递归计算所有最大路径的 max
    int res = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            res = max(res, dp(i, j));

    printf("%d\n", res);

    return 0;
}

