/*
动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。

A 吃 B，B 吃C，C 吃 A。

现有 N 个动物，以 1∼N 编号。

每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 N 个动物所构成的食物链关系进行描述：

第一种说法是 1 X Y，表示 X 和 Y 是同类。

第二种说法是 2 X Y，表示 X 吃 Y。

此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。

当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

当前的话与前面的某些真的话冲突，就是假话；
当前的话中 X 或 Y 比 N 大，就是假话；
当前的话表示 X 吃 X，就是假话。
你的任务是根据给定的 N 和 K 句话，输出假话的总数。

输入格式
第一行是两个整数 N 和 K，以一个空格分隔。

以下 K 行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中 D 表示说法的种类。

若 D=1，则表示 X 和 Y 是同类。

若 D=2，则表示 X 吃 Y。

输出格式
只有一个整数，表示假话的数目。

数据范围
1≤N≤50000
0≤K≤100000
*/
/*
并查集-食物链
1、可以用与根节点的距离表示 与 根节点 吃与被吃的关系，且是环形的三种动物
2、如果与根节点的距离是 1， 则可以吃根节点，如果距离是 2，则被根节点吃，如果距离是 3，则和根节点是同类
3、（dx-dy）%3 表示x到y的距离来判别x与y的关系，余 0 = 同类、余 1 = x吃y，余 2 = y吃x， 总之，距离+1 吃距离+0
4、当规定了 吃与被吃的关系的时候，才可以被加入到同一个集合（这里的同一集合不一定是同一种类，只是表示被指示了吃与被吃的关系才）
5、或者规定了同一个种类的时候也可以加入到同一个集合
6、父子节点的距离不一定是 1，因为压缩路径
*/
#include <iostream>

using namespace std;

const int N = 50010;

int n, m;
int p[N], d[N];//p表示祖宗、d表示到祖宗节点的距离
//返回x的祖宗节点+压缩路径
int find(int x)
{
    if (p[x] != x)
    {
        int t = find(p[x]);
        d[x] += d[p[x]];//累加当前点到祖宗节点的距离
        p[x] = t;       //路径压缩，找到祖宗节点
    }
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    //初始，每个元素都是一个集合，也就是都是树根
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    int res = 0;
    while (m -- )
    {
        int t, x, y;
        scanf("%d%d%d", &t, &x, &y);
        //1、判别肯定的假话
        if (x > n || y > n) res ++ ;
        else
        {
            int px = find(x), py = find(y);
            //2、告诉x与y是同一类
            if (t == 1)
            {   //2.1、同一集合--但是x与y的距离 模3 不等于 0，所以“同类”是为假话
                if (px == py && (d[x] - d[y]) % 3) res ++ ;
                //2.2、不同一个集合--那就更新为一个集合（自主合并集合），更新x的原来祖宗的新祖宗、到新祖宗的距离
                else if (px != py)
                {
                    p[px] = py;         //更新px的祖宗为py，所以d[px]就是px到y的距离，至于x到新祖宗的距离会在find的时候重新求取、下一行也进行了求取
                    d[px] = d[y] - d[x];//（dx + ？ -dy）% 3 = 0            x到y的距离 模3  等于0   ===   x、y是同类
                }
            }
            //3、告诉x吃y，因此x到根节点的距离模3 比 y到根节点距离模3 不等与 1（等于0或者等于2）
            else
            {
                //3.1、同一集合--但是x到y的距离减1 模3 不等于 0，所以“x吃y”是假话
                if (px == py && (d[x] - d[y] - 1) % 3) res ++ ;
                //3.2、不同一个集合--那就更新为一个集合（自主合并集合），更新x的原来祖宗的新祖宗、到新祖宗的距离
                else if (px != py)
                {
                    p[px] = py;             //更新px的祖宗为py，所以d[px]就是px到y的距离
                    d[px] = d[y] + 1 - d[x];//（dx + ？ -dy - 1）% 3 = 0    x到y的距离减1 模3 等于 0  ===  x吃y
                }
            }
        }
    }

    printf("%d\n", res);

    return 0;
}