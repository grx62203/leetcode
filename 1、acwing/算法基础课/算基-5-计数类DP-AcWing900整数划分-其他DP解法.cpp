/*
一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数 n 的一种划分。

现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。

输入格式
共一行，包含一个整数 n。

输出格式
共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 109+7 取模。

数据范围
1≤n≤1000
*/
/*
其他算法
状态表示：
f[i][j]表示总和为i，总个数为j的方案数
状态转移方程：
	1、最小值是1
		f[i - 1][j - 1]  当前方案数 = 和为 i-1，个数为 j-1 的方案数 ，另外多一个 1 便是这个方案
	2、最小值不是1
		f[i - j][j]      当前方案数 = 和为 i,   个数为 j   的方案数 ，把方案中每一个数-1仍合法，故替换
		//当最小值大于1时,把每一个数都减去1后每一个数仍大于等于1，仍合法，因此此时方案数等于把当前每个数减1的方案数
f[i][j] = f[i - 1][j - 1] + f[i - j][j];
再累加总和是n，个数为1、2、3、4、、、、的各种方案数
*/

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, mod = 1e9 + 7;

int n;
int f[N][N];

int main()
{
    cin >> n;
    //和为 1，只有一种，个数也为 1
    f[1][1] = 1;
    //遍历当前总和，从 2 到 n
    for (int i = 2; i <= n; i ++ )
    	//遍历总个数
        for (int j = 1; j <= i; j ++ )
            f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod;
    //累加 所有 总个数不同的情况
    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = (res + f[n][i]) % mod;

    cout << res << endl;

    return 0;
}
