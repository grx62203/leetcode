/*
给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

删除–将字符串 A 中的某个字符删除。
插入–在字符串 A 的某个位置插入某个字符。
替换–将字符串 A 中的某个字符替换为另一个字符。
现在请你求出，将 A 变为 B 至少需要进行多少次操作。

输入格式
第一行包含整数 n，表示字符串 A 的长度。

第二行包含一个长度为 n 的字符串 A。

第三行包含整数 m，表示字符串 B 的长度。

第四行包含一个长度为 m 的字符串 B。

字符串中均只包含大小写字母。

输出格式
输出一个整数，表示最少操作次数。

数据范围
1≤n,m≤1000
输入样例：
10 
AGTCTGACGC
11 
AGTAAGTAGGC
*/
/*
0、DP
    状态表示 f[i][j]
        集合   
            所有 将a[1~i]变成b[1~j]的操作方式的 操作数最小值 
        属性   
            最小值
    状态计算
        本质就是集合的划分
        1)删除操作：把a[i]删掉之后a[1~i]和b[1~j]匹配
            所以之前要先做到a[1~(i-1)]和b[1~j]匹配
            f[i-1][j] + 1
        2)插入操作：插入之后a[i]与b[j]完全匹配，所以插入的就是b[j] 
            那填之前a[1~i]和b[1~(j-1)]匹配
            f[i][j-1] + 1 
        3)替换操作：把a[i]改成b[j]之后想要a[1~i]与b[1~j]匹配 
            那么修改这一位之前，a[1~(i-1)]应该与b[1~(j-1)]匹配
            f[i-1][j-1] + 1
            但是如果本来a[i]与b[j]这一位上就相等，那么不用改，即
            f[i-1][j-1] + 0
*/

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
char a[N], b[N];
int f[N][N];

int main()
{
    scanf("%d%s", &n, a + 1);
    scanf("%d%s", &m, b + 1);

    for (int i = 0; i <= m; i ++ ) f[0][i] = i;
    for (int i = 0; i <= n; i ++ ) f[i][0] = i;

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);          //删除、插入
            if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]);//替换之前相等，不替换
            else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);         //替换之前不相等，替换
        }

    printf("%d\n", f[n][m]);

    return 0;
}



/*************************************************************************************/
思路一：
1.状态表示 ：f[i][j]
    集合：将a[1~i]变成b[1~j]的操作方式
    属性：min
2.状态计算 ：从最后一步考虑
    有三种操作，所以有三个子集
        1)删除操作：把a[i]删掉之后a[1~i]和b[1~j]匹配
            所以之前要先做到a[1~(i-1)]和b[1~j]匹配
            f[i-1][j] + 1
        2)插入操作：插入之后a[i]与b[j]完全匹配，所以插入的就是b[j] 
            那填之前a[1~i]和b[1~(j-1)]匹配
            f[i][j-1] + 1 
        3)替换操作：把a[i]改成b[j]之后想要a[1~i]与b[1~j]匹配 
            那么修改这一位之前，a[1~(i-1)]应该与b[1~(j-1)]匹配
            f[i-1][j-1] + 1
            但是如果本来a[i]与b[j]这一位上就相等，那么不用改，即
            f[i-1][j-1] + 0
    考虑状态转移的时候
        先考虑如果我没有进行这个操作应该是什么状态
        然后考虑你进行这一步操作之后会对你下一个状态造成什么影响
        然后再加上之前状态表示中你决策出来的那个DP属性
    这样就可以自然而然地搞出来转移方程啦



好的那么f[i][j]就由以上三个可能状态转移过来，取个min
细节问题：初始化怎么搞
先考虑有哪些初始化嘛
1.你看看在for遍历的时候需要用到的但是你事先没有的
（往往就是什么0啊1啊之类的）就要预处理 
2.如果要找min的话别忘了INF
  要找有负数的max的话别忘了-INF

ok对应的： 
1.f[0][i]如果a初始长度就是0，那么只能用插入操作让它变成b
  f[i][0]同样地，如果b的长度是0，那么a只能用删除操作让它变成b
2.f[i][j] = INF //虽说这里没有用到，但是把考虑到的边界都写上还是保险
最后代码

#include<bits/stdc++.h>
using namespace std;
const int INF = 2e9;
const int N = 2333;
int lena,lenb,f[N][N];
char a[N],b[N];

int main() {
    scanf("%d%s",&lena,a+1);
    scanf("%d%s",&lenb,b+1);
    for(register int i=1; i<=lena; i++) 
        for(register int j=1; j<=lenb; j++) 
            f[i][j] = INF;

    for(register int i=1; i<=lena; i++) f[i][0] = i;
    for(register int i=1; i<=lenb; i++) f[0][i] = i;

    for(register int i=1; i<=lena; i++) {
        for(register int j=1; j<=lenb; j++) {
            f[i][j] = min(f[i-1][j]+1,f[i][j-1]+1);
            if(a[i]==b[j]) f[i][j] = min(f[i][j],f[i-1][j-1]);
            else f[i][j] = min(f[i][j],f[i-1][j-1]+1);
        }
    }
    printf("%d\n",f[lena][lenb]);
    return 0;
}
/*************************************************************************************/