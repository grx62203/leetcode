/*
给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 n。

第二行包含 n 个数字，其中第 i 个数字表示第 i 堆石子的数量。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1≤n≤105,
1≤每堆石子数≤109
*/
/*
1、因为相与出来不为0的数最终的结果和为0是交替进行的，所有的数每次取完石子之后都会变小，所以始终为0的那一边最终会变成全部为0的状态。
2、先手必胜
    就是让对手必败
    拿一定的石子，然后剩下的某种结果可以让对手先拿多少，先手跟着拿多少，一直模仿，然后使对手必败
    这个某种结果可以表示为  a1^a2^a3^a4^a5^^^^ = 0
    所以先手必胜 a1^a2^a3^a4^a5^^^^ != 0
    所以先手必败 a1^a2^a3^a4^a5^^^^  = 0
    异或 为 0 代表 总有一个石头与另一个石头相匹配对应，如果为0，就代表后拿的可以完全仿造前面那个人的操作，就不败之地
*/


#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;


int main()
{
    int n;
    scanf("%d", &n);

    int res = 0;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        res ^= x;
    }

    //所有数量一一相异或
    if (res) puts("Yes");
    else puts("No");

    return 0;
}

