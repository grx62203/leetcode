/*
奶牛贝茜正在学习如何在不同进制之间转换数字。

但是她总是犯错误，因为她无法轻易的用两个前蹄握住笔。

每当贝茜将数字转换为一个新的进制并写下结果时，她总是将其中的某一位数字写错。

例如，如果她将数字 14 转换为二进制数，那么正确的结果应为 1110，但她可能会写下 0110 或 1111。

贝茜不会额外添加或删除数字，但是可能会由于写错数字的原因，写下包含前导 0 的数字。

给定贝茜将数字 N 转换为二进制数字以及三进制数字的结果，请确定 N 的正确初始值（十进制表示）。

输入格式
第一行包含 N 的二进制表示，其中一位是错误的。

第二行包含 N 的三进制表示，其中一位是错误的。

输出格式
输出正确的 N 的值。

数据范围
0≤N≤109，且存在唯一解。
*/
/*
暴力解法
枚举一边转换判断，不可取
那么可以反过来枚举-和a只有一位不同的数，最多只有三十位，也就是三十次
同理，枚举和b不同的，也就是不超过六十次
然后找到一位公共的数，唯一解
哈希表来存集合，unordeered_set
计算量不到1000
*/
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_set>

using namespace std;

int get(string s, int b)  // 将b进制的数转化成十进制
{
    int res = 0;
    // 秦九韶算法
    for (auto c: s)
        res = res * b +  c - '0';//ASCII码转换为十进制
        //原来的res 向高位移动一位，再加上现在的 c所代表的 十进制写法（c - ‘0’  就是将字符转换为数）
    return res;
}

int main()
{
    string a, b;
    //cin >> a >> b;
    a = "1010";
    b = "212";

    unordered_set<int> S;

    for (auto& c: a)//从高位到低位去枚举
    {
        c ^= 1;//异或是相同为0，不同为1, 这里的作用是让 0、1对换
        S.insert(get(a, 2));
        c ^= 1;
    }

    for (auto& c: b)
    {
        char t = c;
        for (int i = 0; i < 3; i ++ )
            if (i + '0' != t)// 数字变为ASCII码后，与现有的不一样，那代表 i 就是 c的回正版本
            {
                c = i + '0';//然后将ASCII码变为十进制
                int x = get(b, 3);
                if (S.count(x))//如果发现枚举的这个数在集合中，那么找到答案，答案唯一
                {
                    cout << x << endl;
                    return 0;
                }
            }
        c = t;
    }

    return 0;
}
