/*
尽管奶牛贝茜发现每个平衡括号字符串都很美观，但她特别喜欢被她称为“完全”平衡的括号字符串----一个由 ( 构成的字符串后接一个长度相同的 ) 构成的字符串。

例如：

(((())))
有一天，当贝茜穿过牛棚时，她发现地面上有一个 N×N 的马蹄铁矩阵。每个马蹄铁的方向都看上去像 ( 或 )。

从矩阵的左上角开始，贝茜希望四处走动以拾起马蹄铁，使得她捡起的马蹄铁按顺序构成的括号字符串是完全平衡的。

请计算她能得到的最长完全平衡括号字符串的长度。

每一步中，贝茜可以沿上下左右四个方向移动。

她只能移动到包含马蹄铁的方格区域内，当她进入该区域时就会拿起那里的马蹄铁，并无法再次回到该位置（因为该位置没有马蹄铁了）。

她首先拿起的是左上角的马蹄铁。

由于她拿起的马蹄铁要形成一个完全平衡的字符串，因此她可能无法将所有马蹄铁都拿起来。

输入格式
第一行包含整数 N。

接下来 N 行，每行包含一个长度为 N 的括号字符串，用来表示括号矩阵。

输出格式
输出她能得到的最长完全平衡括号字符串的长度。

如果无法得到完全平衡括号字符串（例如，左上角马蹄铁形如 )），则输出 0。

数据范围
2≤N≤5
*/
/*
暴力搜索
（递归搜索树）
状态机 
第一个是左括号，第二个都可以
第一个是右括号，第二个必须是右括号
*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
char g[N][N];//元素表示
bool st[N][N];//标记有没有被搜索过
int ans;      //表示答案

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void dfs(int x, int y, int l, int r)
{
    st[x][y] = true;//标记 被搜索过

    if (l == r) //数量相同，判断是否需要更新答案
    {
        ans = max(ans, l + r);
        st[x][y] = false;//退出之前， 恢复现场
        return;
    }

    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < n && b >= 0 && b < n && !st[a][b])//如果没有越界，且没有搜索过
        {
            if (g[x][y] == ')' && g[a][b] == '(') continue;//只有这一种情况的状态机是非法的，其他都是合法的
            if (g[a][b] == '(') dfs(a, b, l + 1, r);       //如果当前是左括号，左括号++
            else dfs(a, b, l, r + 1);                      //如果当前是右括号，右括号++
        }
    }

    st[x][y] = false;//退出之前，恢复现场
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> g[i];

    if (g[0][0] == '(') //只有左上角是 左括号 的时候，才需要去搜索
        dfs(0, 0, 1, 0);//从左上角开始，左括号 = 1， 右括号 = 0

    cout << ans << endl;
    return 0;
}