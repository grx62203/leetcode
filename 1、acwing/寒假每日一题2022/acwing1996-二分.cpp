/*
农夫约翰将按字典序排列的 N 头奶牛的名字列表贴在了牛棚的门上。

每个奶牛的名字都由一个长度介于 1 到 20 之间的由小写字母构成的唯一字符串表示。

麻烦制造者贝茜将列表中的奶牛名字重新排序打乱了列表。

此外，她还对每头奶牛的名字中的字母顺序进行了重新排列（也可能保持不变）。

给定修改过后的列表，请帮助约翰确定列表中的每个名字可能出现在原始列表中的最低和最高位置。

输入格式
第一行包含整数 N。

接下来 N 行，按照修改过后列表的顺序，给出了修改过后的奶牛的名字。

输出格式
共 N 行，第 i 行输出给定的第 i 个字符串在原始列表中可能的最低和最高位置。

数据范围
1≤N≤50000
*/
/*
二分
一定存在一个唯一的升序
=当前数取最小值，其余数取最大值，便可得到当前数的最前位置
=反之，可以得到当前数的最后位置
利用二分去找最前位置与最后位置
1、先将所有的字符串的最大值进行排列得到数组
2、当前目标的求得最小值，求得最靠前的大于等于目标最小值的位置，插到前面 k，然后将后面原来的位置删掉，不会对前面影响，这就是最前位置 k，
3、后将所有的字符串的最小值进行排列得到数组
4、当前目标的求得最大值，求得最靠后的大于等于目标最大值的位置，插到后面 k+1 ，然后将前面原来的位置删掉，后面所有的排名都减去 1 ，这就是最后位置 k
5、两次二分找到的位置终究都是实际要求的两个可能的最前最后排名
*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 50010;

int n;
string a[N], b[N], c[N];//原数组，第一次最小值的排序、第二次最大值的排序

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> a[i];
        b[i] = c[i] = a[i];
        sort(b[i].begin(), b[i].end(), greater<char>());//将当前的字符串求得最大值，也就是倒序依次
        sort(c[i].begin(), c[i].end());                 //将当前的字符串求得最小值，顺序
    }

    sort(b + 1, b + n + 1);//对都是最大值的数组进行排序
    sort(c + 1, c + n + 1);//对都是最小值的数组进行排序

    for (int i = 1; i <= n; i ++ )//枚举每个字符串，得到两个可能的排名，一个最前的一个最后的
    {
        sort(a[i].begin(), a[i].end());//将当前字符串重新排列，得到字符串的最小值，顺序
        int l = 1, r = n;// 数组是从 1 开始存储的
        while (l < r)//对数组b找到 最靠前的 大于等于 a[i]的位置
        {
            int mid = l + r >> 1;
            if (b[mid] >= a[i]) r = mid;
            else l = mid + 1;
        }

        cout << r << ' ';
        reverse(a[i].begin(), a[i].end());//将当前字符串重新排列，得到字符串的最大值，逆序
        l = 1, r = n;
        while (l < r)//对数组b找到 最靠后的 大于等于 a[i]的位置
        {
            int mid = l + r + 1 >> 1;//找左区间的右边界的话，需要 + 1 再 除以 2
            if (c[mid] <= a[i]) l = mid;
            else r = mid - 1;
        }

        cout << r << endl;
    }

    return 0;
}