/*
干了一整天的活，农夫约翰完全忘记了他把拖拉机落在田地中央了。

他的奶牛非常调皮，决定对约翰来场恶作剧。

她们在田地的不同地方放了 N 捆干草，这样一来，约翰想要开走拖拉机就必须先移除一些干草捆。

拖拉机的位置以及 N 捆干草的位置都是二维平面上的整数坐标点。

拖拉机的初始位置上没有干草捆。

当约翰驾驶拖拉机时，他只能沿平行于坐标轴的方向（北，南，东和西）移动拖拉机，并且拖拉机必须每次移动整数距离。

例如，驾驶拖拉机先向北移动 2 单位长度，然后向东移动 3 单位长度。

拖拉机无法移动到干草捆占据的位置。

请帮助约翰确定他需要移除的干草捆的最小数量，以便他能够将拖拉机开到二维平面的原点。

输入格式
第一行包含三个整数：N 以及拖拉机的初始位置 (x,y)。

接下来 N 行，每行包含一个干草捆的位置坐标 (x,y)。

输出格式
输出约翰需要移除的干草捆的最小数量。

数据范围
1≤N≤50000,
1≤x,y≤1000
*/
/*
BFS+双端队列广搜
（没有赋权的、简化版的dijkstra算法，堆换成了双端队列，堆每次取最小值）
可以转化为最短路问题，此时最短路的定义是经过最少的草堆（“X”）=证明等价性
抽象化= 点、边、点权
	如果格子是障碍物的化，权值就是1，空白就是0，起点是S，终点是T
从每个点扩展的时候
	点权是0，加到对头、点权是1 ，加到队尾  //每个点出队（扩展）一次、入队可能多次，需要在出队的时候判重
证明两段性：
	任何时刻双端队列中所有点距离原点的距离，最多只有两段、 差为 1	，表示为x 与 x+1
因为可以走到地图外面
	假设一个可以走的范围，刚好包括这个1000范围，扩展一圈从 0-1001就可以，不需要扩展复数
*/
#include <iostream>
#include <cstring>
#include <algorithm>
#include <deque>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;//点用pair来存，然后用x、y来重定义
const int N = 1010;//表示障碍物的数量

bool g[N][N], st[N][N];//g表示障碍物的位置、st表示某个位置是否被搜索的标记数组
int dist[N][N];        //定义距离数组

int bfs(int sx, int sy)
{
    deque<PII> q;         //定义双端队列
    q.push_back({sx, sy});//3、将起点加进双端队列中
    memset(dist, 0x3f, sizeof dist);//将距离数组初始化为 正无穷
    dist[sx][sy] = 0;//起点距离改为 0

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};//上右下左四个偏移量数组（顺时针）

    while (q.size())//队列不空的时候
    {
        auto t = q.front();//4、队列不空，则取出队列第一个元素，也就是 优先 搜索 权值 为0 的地方，尽可能满足最小距离
        q.pop_front();     //然后删掉

        //11、补充 这可能就是dijkstra算法的出队判重，搜索过便不再搜索
        if (st[t.x][t.y]) continue;//5、如果已经被搜索过，即不为false，再开下一个循环，继续队列取头
        st[t.x][t.y] = true;       //标记被搜索

        if (!t.x && !t.y) break;  //9、如果 x、y都为 0 ，走到终点，break

        for (int i = 0; i < 4; i ++ )//搜索当前位置的四个方向
        {
            int x = t.x + dx[i], y = t.y + dy[i];//6、遍历四个方向，求<当前方向新的点>的坐标
            if (x >= 0 && x < N && y >= 0 && y < N)//条件语句 控制住 0-1001的 范围内
            {
                int w = 0;         //默认<当前方向新的点> 的 权值 为 0
                if (g[x][y]) w = 1;//7、如果<当前方向新的点> 是障碍物，权值 更新为 1
                if (dist[x][y] > dist[t.x][t.y] + w)//如果<当前方向新的点>的距离可以被更新，
                {
                    dist[x][y] = dist[t.x][t.y] + w;
                    //8、可以被更新，要么未遍历=正无穷，要么已遍历但距离大可以被更小距离的路替换
                    //更新<当前方向新的点>的距离，更新不代表是答案，只代表走这条路，有更小的权值
                    //尽量让从起点到这个点的 自定义距离最短，这就是dijkstra算法
                    //如果到某个点有多条路径一次比一次 短， 那就是 多次入队
                    //由于有出队判重搜索一次，所以以防 多条 路径 找不到最短的那条，于是先搜索 队头（权值等于0的部分先走完）
                    if (!w) q.push_front({x, y});//如果 <当前方向新的点> 权值 是 0， 加到队头
                    else q.push_back({x, y});    //否则，加到队尾
                }
            }
        }
    }

    return dist[0][0];//10、返回从起点到终点的最小自定义距离的路线 的长度 = 去掉草堆的数量
}

int main()
{
    int n, sx, sy;//草堆数量，起点x、起点y
    scanf("%d%d%d", &n, &sx, &sy);
    while (n -- )//1、读入n个障碍物的坐标
    {
        int x, y;
        scanf("%d%d", &x, &y);
        g[x][y] = true;//2、且将矩阵图 上障碍物 点权 置 1
    }

    printf("%d\n", bfs(sx, sy));

    return 0;
}