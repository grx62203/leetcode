/*
贝茜对她最近在农场周围造成的一切恶作剧感到抱歉，她同意帮助农夫约翰把一批新到的干草捆堆起来。

开始时，共有 N 个空干草堆，编号 1∼N。

约翰给贝茜下达了 K 个指令，每条指令的格式为 A B，这意味着贝茜要在 A..B 范围内的每个干草堆的顶部添加一个新的干草捆。

例如，如果贝茜收到指令 10 13，则她应在干草堆 10,11,12,13 中各添加一个干草捆。

在贝茜完成了所有指令后，约翰想知道 N 个干草堆的中值高度——也就是说，如果干草堆按照高度从小到大排列，位于中间的干草堆的高度。

方便起见，N 一定是奇数，所以中间堆是唯一的。

请帮助贝茜确定约翰问题的答案。

输入格式
第一行包含 N 和 K。

接下来 K 行，每行包含两个整数 A,B，用来描述一个指令。

输出格式
输出完成所有指令后，N 个干草堆的中值高度。
*/
/*
差分-模板
(和前缀和正好相反)
排序：sort（nlogn）、nth_element更快（n）、桶排序（n）
输入数量超过五次方，用scanf
*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n, m;
int b[N];

int main()
{
    scanf("%d%d", &n, &m);

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        b[l] ++, b[r + 1] -- ;
        //然后进行变式前缀和的时候，l到r都可以加1，但是到了r+1以及以后，就会用这个 -1 抵消掉b[l]++的作用
        //变式前缀和之后，l 到  r之间都加上了此时标记的1，之后的都没加上，就变相的进行了l-r范围的加1
    }

    for (int i = 1; i <= n; i ++ ) b[i] += b[i - 1];//变式前缀和

    //sort(b+1, b + n + 1);
    nth_element(b + 1, b + n / 2 + 1, b + n + 1);

    printf("%d\n", b[n / 2 + 1]);//找到中间的数，一定是奇数总

    return 0;
}
