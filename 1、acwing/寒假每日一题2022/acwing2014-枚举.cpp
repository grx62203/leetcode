/*
每当下雨时，农夫约翰的田地总是被洪水淹没。

由于田地不是完全水平的，所以一些地方充满水后，留下了许多被水隔开的“岛”。

约翰的田地被描述为由 N 个连续高度值 H1,…,HN 指定的一维场景。

假设该场景被无限高的围墙包围着，请考虑暴雨期间发生的情况：

最低处首先被水覆盖，形成一些不连贯的岛，随着水位的不断上升，这些岛最终都会被覆盖。

一旦水位等于一块田地的高度，那块田地就被认为位于水下。

fig_islands.png

上图显示了一个示例：在左图中，我们只加入了刚好超过 1 单位的水，此时剩下 4 个岛（最大岛屿剩余数量），而在右图中，我们共加入了 7 单位的水，此时仅剩下 2 个岛。

请计算，暴风雨期间我们能在某个时间点看到的最大岛屿数量。

水会一直上升到所有田地都在水下。

输入格式
第一行包含整数 N。

接下来 N 行，每行包含一个整数表示 Hi。

输出格式
输出暴风雨期间我们能在某个时间点看到的最大岛屿数量。

数据范围
1≤N≤105,
1≤Hi≤109
*/
/*
枚举优化
因为数据量 10^5,所以需要 logn的时间复杂度，但是枚举是 n^2，所以需要优化
1、只考虑变化的部分  O（n）
2、从没有被淹没到 被淹没 对答案的影响是什么，
	一、中间小山 比左边高、比右边矮    ==不影响答案 0
	二、中间小山 比左边矮、比右边高    ==不影响答案 0
	三、中间小山 最高                ==答案减少   -1
	四、中间小山 最矮                ==答案增加   +1
但是不确定相等高度的小山的邻接长度，所以每一次遍历不一定是O（1）
研究发现，相等高度的邻接小山 可以当作一个，一开始判重删掉
*/
#include <iostream>
#include <cstring>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;//表示 下标 与 高度，pair可以直接排序，不需要重载 <

const int N = 100010;//数据范围

int n;
int h[N];//所有山的高度记录
PII q[N];//排序的元素 为 pair数组

int main()
{
    scanf("%d", &n);                                  //读入山的数量
    for (int i = 1; i <= n; i ++ ) scanf("%d", &h[i]);//读入山的高度，从下标1 开始，所有后面操作也需要从 1 开始

    n = unique(h + 1, h + n + 1) - h - 1;             // 判重，删掉相等高度 的邻接小山，留下一个独特的
	//只是去重相邻，直接unique，如果想要完全去重，需要先sort
    //unique（第一个位置，最后一个位置的下一个）= 删除结束的最后一个元素的下一个元素，因为形参表示区间为 前闭后开
	//unique - h - 1 得到去重后的真实数量， 因为h 表示数组 本来首元素的位置但没有存放，h + 1 表示存放实际第一个元素的位置

    for (int i = 1; i <= n; i ++ ) q[i] = {h[i], i};//将更新下标的所有的小山存储  <高度，新的连续的下标>

    sort(q + 1, q + n + 1);                         //排序，这里的顺序不影响小山的自身高度、下标，只是规定了枚举小山丛下往上的一个顺序

    int res = 1, cnt = 1;                           //定义答案、定义当前的小山数量，初始答案为 1、 小山数量为 1 
    for (int i = 1; i <= n; i ++ )                  //从低到高枚举所有的小山
    {
        int k = q[i].y;                             //找到当前小山的下标
        if (h[k - 1] < h[k] && h[k + 1] < h[k]) cnt -- ;     //三、中间小山 最高  ==答案减少   -1
        else if (h[k - 1] > h[k] && h[k + 1] > h[k]) cnt ++ ;//四、中间小山 最矮  ==答案增加   +1

        if (q[i].x != q[i + 1].x)  // 如果下一个 远处的 小山 高度与当前 相同，则不能更新答案.//这里不能用 q[i-1]
            res = max(res, cnt);
    }

    printf("%d\n", res);

    return 0;
}

