


----------------------------------------------------------------------------
--------------------------接雨水---------------------------------------------


--------------------------接雨水---------------------------------------------
//y总思路
1、入栈的条件
	for循环的最后每个都入
2、出栈的条件
	比i柱子低就出栈，计算上一个while循环弹出的柱子对应的凹槽
	res += (height[stk.top()] - last) * (i - stk.top() - 1);
3、计算的凹槽
	左低中低右高 =公式1（此时栈顶是左墙可以计算中间柱子对应凹槽，计算结束后需要再进入循环进行弹出，同时计算左墙对应的凹槽）
	左高中低右低 =公式2（此时栈顶是左墙可以计算中间柱子对应凹槽，计算后不必弹出判断）
4、需要判定凹槽一定存在，且滞后计算对应体积（左中右）=栈顶（左）、last（中）、i（右）
	第一次进循环的时候，公式无效，存下当前柱子高度，弹出当前柱子，
	后面还能进循环，就代表还存在比i柱子低的，代表可以计算刚才弹出去的柱子所在的凹槽了
	左中右，右边高，取决于左中高度差，是一个扁矩形
	res += (height[stk.top()] - last) * (i - stk.top() - 1);
	如果没进while循环，栈不空，代表没有前面比i柱子还低的只有比i柱子高的，此时公式无效
	如果退出while循环，栈不空，代表可以计算刚才最后弹出的柱子对应凹槽了
	左中右，右边高，取决于左中高度差，是一个扁矩形
    if (stk.size()) res += (i - stk.top() - 1) * (height[i] - last);
		for (int i = 0; i < height.size(); i ++ ) {
            int last = 0;
            while (stk.size() && height[stk.top()] <= height[i]) {      //非空 且 栈顶元素 小于等于 当前高度
				//top是左边即将被弹出的，如果是左边第一个，
				//第一次进循环的时候，公式无效，存下当前柱子高度，弹出当前柱子，
                //后面还能进循环，就代表还存在比i柱子低的，代表可以计算刚才弹出去的柱子所在的凹槽了
				//左中右，右边高，取决于左中高度差，是一个扁矩形
                res += (height[stk.top()] - last) * (i - stk.top() - 1);
                //last是左边即将被弹出的高度
                last = height[stk.top()];  
                //将所有比i柱子低的都弹出去                             
                stk.pop(); 
                
            }
		    //如果没进while循环，栈不空，代表没有前面比i柱子还低的只有比i柱子高的，此时公式无效
		    //如果退出while循环，栈不空，代表可以计算刚才最后弹出的柱子对应凹槽了
		    //左中右，右边高，取决于左中高度差，是一个扁矩形
            if (stk.size()) res += (i - stk.top() - 1) * (height[i] - last);
            stk.push(i);
        }
	
//Diamondz思路
		for (int i = 0; i < height.size(); i ++ )
        {
        	//找到每个柱子左边的第一个高或者相等的柱子、右边的第一个大于的柱子，然后比较两边高度再计算横向凹槽的体积
            while (!stk.empty() && height[stk.top()] < height[i])
            {
                int t = stk.top();
                stk.pop();
                if (stk.empty()) break;
                int len = i - stk.top() - 1;
                int h = min(height[stk.top()], height[i]) - height[t];
                res += h * len;
            }
            stk.push(i);
        }
        return res;
以上都是遍历右墙，然后对于左边更低的柱子进行计算，被计算的柱子对应的一定范围内的横向凹槽是一个有横向范围的扁矩形







