背包问题
416.分割等和子集
1049.最后一块石头的重量 II
494.目标和
474.一和零





----------------------------------------------------------------------------

--------------------------正则表达式匹配leetcode10---------------------------








--------------------------正则表达式匹配leetcode10---------------------------
一般用递推-for循环
dp[a][b]  可以表示前a个和前b个匹配的结果  
    
动态规划dp---循环或者递归，循环效率更高
    状态表示
    	集合           所有的 s[1~i]和p[1~i]的匹配方案  //*到底表示几个字符
    	属性(存储的值)  bool 是否存在一个合法方案
    状态计算
    	p[j] ！= '*'   (s[i] == p[i] || p[j] == '.' ) && f(i-1,j-1)
    	p[j] == '*'    需要找到*代表多少个字符,枚举
			表示0个字符||表示1个字符                           ||表示2个字符                                                      ||等等
    		f(i, j-2)||f(i, j-1)&&(s[i]==p[j-1]||p[j-1]=='.')||f(i-2, j-2)&&(s[i]==p[j-1]||p[j-1]=='.')&&(s[i-1]==p[j-1]||p[j-1]=='.') ||

(a*) 是一个整体
需要从所有匹配方式中找到一个合法方案，dp每次可以处理一堆方案
f(i,j)   = f(i, j-2)   || f(i-1, j-2)&&(s[i]与p[j-1]匹配)      || f(i-2, j-2)&&(s[i]与p[j-1]匹配)&&(s[i-1]与p[j-2]匹配) | .....
f(i-1,j) =                f(i-1, j-2)                          || f(i-2, j-2)&&(s[i-1]与p[j-2]匹配)  || .....
	因此发现 f(i-1,j) &&(s[i]与p[j-1]匹配)   就是f(i,j)的后半部分
f(i,j) =  f(i,j-2) || f(i-1,j) &&(s[i]与p[j-1]匹配)

f(1,0)一定是不匹配的，所有j从1开始循环，i也要从1开始，前面赋予空格都是防止下标越界





