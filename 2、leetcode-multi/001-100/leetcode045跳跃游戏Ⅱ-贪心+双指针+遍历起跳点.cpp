/*
给你一个非负整数数组 `nums` ，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
假设你总是可以到达数组的最后一个位置。


**示例 1:**
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
*/

//用cur来遍历 一个又一个小分段
    起点 -jump- 范围（0，1】 -ans++   找到起点能跳的最远位置，定位 1；        范围（0，1】 就是 1 步能跳到的范围
（0，1】 -jump- 范围（1，2】 -ans++   找到（0，1】范围内跳的最远位置，定位 2； 范围（1，2】 就是 2 步能跳到的范围
（1，2】 -jump- 范围（2，3】 -ans++   找到（1，2】范围内跳的最远位置，定位 3   范围（2，3】 就是 3 步能跳到的范围
        
class Solution {
public:
    int jump(vector<int>& nums) {
        const int n = nums.size();
        int ans = 0, cur = 0, dis = 0;
	    //循环更新 每一步能跳到的最远范围，每当找到 每个步数范围的最远距离】的时候，更新步数ans、下一次起跳范围（1，2】
        while (dis < n - 1) {
        	//更新前一段范围 能跳到的最远距离，
        	//next是当前范围能跳到的最远距离
        	//dis是上一范围能跳到的最远距离
        	//cur的范围是（0，1】、（1，2】，遍历上一范围
            int next = 0;
            while (cur <= dis) {
                next = max(next, cur + nums[cur]); //当前这一位置能到达的最远位置
                cur++;                             //递进位置
            }
            ans++;       //多了一个范围
            dis = next;  //代表就是这一次范围能跳到范围的最远位置1】、2】
        }
        return ans;
    }
};
