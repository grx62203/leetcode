/*
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
*/

class Solution {
public:
    int numTrees(int n) {
        vector<int> f(n + 1);
        f[0] = 1;
        //遍历 树的 节点数目
        for (int i = 1; i <= n; i ++ )
            //当前数目的情况下，从前到后遍历左子树的数目 0 ~ n-1，然后每一次添加 左子树的数目 * 右子树的数目
            for (int j = 1; j <= i; j ++ )
                f[i] += f[j - 1] * f[i - j];//每一次都是某个左子树的可能 * 对应数量的右子树的可能
        return f[n];
    }
};