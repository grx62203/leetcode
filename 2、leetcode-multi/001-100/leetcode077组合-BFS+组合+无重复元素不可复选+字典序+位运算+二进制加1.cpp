/*
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。
1 <= n <= 20
1 <= k <= n
*/
//8ms 
//====如果最后是连续的0，找到前面连续的1，把最前面的1与再前面的0换位置，后面剩下的1放到最末尾
//====如果最后是连续的1，把最前面的1与再前面的0换位置
class Solution {
public:
    vector<int> temp;//低位在前，高位在后，选择了第几位就加入几-----135就是选择了第1、3、5位
    vector<vector<int>> ans;

    vector<vector<int>> combine(int n, int k) {
        // 初始化，也是字典序的第一个组合结果
        // 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]
        // 末尾加一位 n + 1 作为哨兵
        for (int i = 1; i <= k; ++i) {
            temp.push_back(i);
        }
        temp.push_back(n + 1);//哨兵
        
        int j = 0;
        //每次循环都要从当前k个1的二进制跳到 字典序排列的下一个也是k个1的二进制。再一一加入答案
        while (j < k) {
            ans.emplace_back(temp.begin(), temp.begin() + k);
            j = 0;
            // 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t
            // 我们需要把 [0, t - 1] 区间内的每个位置上的内容重置成 [1, t]范围的内容 = 后面剩下的1放到最末尾/不操作
            	//最低位是1，找到最后一个1的位置
            	//最低位是0，找到了接下来的连续1位的最后一个1的位置
            while (j < k && temp[j] + 1 == temp[j + 1]) {
                temp[j] = j + 1;//对于每一个 和后一位同时选择的 那一位，要改为选择1、2、3、、、、j--字典最小序原则，
                ++j;
            }
            // j 是第一个 temp[j] + 1 != temp[j + 1] 的位置
            	//然后将这个选择+1，也就是本来第五位是1第六位是0，结果变成第六位是1的一个情况（第五位前面以及被修改为第六位的0了）
            ++temp[j];
        }
        return ans;
    }
};
