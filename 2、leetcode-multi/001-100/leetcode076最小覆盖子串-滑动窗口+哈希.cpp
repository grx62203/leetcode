/*
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。

*/
//16ms

class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> hash;
        int cnt = 0;
        for (auto c : t)
        {
            if (!hash[c]) cnt ++ ;//字符数
            hash[c] ++ ;          //字符计数
        }

        string res = "";
        //左边  j  右边  i  c代表的是去重的字符数量
        for (int i = 0, j = 0, c = 0; i < s.size(); i ++ )
        {
            //右边，如果右点的哈希值降低到1且即将要降低为0的时候，最后一次有效包含这个点，然后累计c
            if (hash[s[i]] == 1) c ++ ;
            //如果是目标字符，降低哈希值，在最后一次一次有效包含的时候累加到c，可以降低为负数
                //在最左边 && c满足条件 才会被剔除冗余
                //其他时候可以保留冗余
            //如果不是目标字符，降低哈希值为负数，不影响答案
            hash[s[i]] -- ;
            //左边，如果数量满足但是左点重复出现，缩短窗口且增加重复点的哈希值，恢复到0的水平
                //hash[]中存储的是t中每个字母出现的次数，减去s[j~i]中出现的次数，所以当j > i时，hash[]中的所有值一定大于等于0，此时循环就会终止。
                //所以s[j++]不会越界
            while (c == cnt && hash[s[j]] < 0) hash[s[j ++ ]] ++ ;
            //如果所有字符都按照次数被包含
                //如果 res没有被更新 或者 新的长度i-j+1 更小
                    //更新res
            if (c == cnt)
            {
                //更新更短的子串
                if (res.empty() || res.size() > i - j + 1) res = s.substr(j, i - j + 1);
            }
        }

        return res;
    }
};


